#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Big Telegram Crypto Bot (aiogram 2.25.1)
Features:
- Token from TELEGRAM_TOKEN env or token.txt
- ccxt (MEXC) for price & OHLCV
- aiosqlite DB for users, symbols, alerts, history
- Inline buttons UI for all flows
- Price polling, history storing, chart generation (candles)
- Autogenerated signals per-user (simple rule engine + indicators)
- Logging to console and file. Errors logged and do not crash bot.
- Expandable template for Railway/Heroku-like deployment
"""

import os
import sys
import time
import json
import math
import asyncio
import logging
import traceback
from datetime import datetime, timedelta
from collections import defaultdict, deque

import requests
import ccxt
import aiosqlite
import pandas as pd
import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import mplfinance as mpf

from apscheduler.schedulers.asyncio import AsyncIOScheduler

from aiogram import Bot, Dispatcher, types
from aiogram.utils import executor
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

# Optional TA lib
try:
    import ta
except Exception:
    ta = None

# ---------------- Configuration ----------------
APP_NAME = "CryptoSignalBot"
DB_PATH = os.getenv("DB_PATH", "bot_data.sqlite")
LOG_FILE = os.getenv("LOG_FILE", "bot.log")
DEFAULT_EXCHANGE_ID = os.getenv("EXCHANGE", "mexc")
PRICE_POLL_INTERVAL = int(os.getenv("PRICE_POLL_INTERVAL", "5"))  # seconds (polling interval)
SIGNAL_CHECK_INTERVAL = int(os.getenv("SIGNAL_CHECK_INTERVAL", "10"))  # seconds
HISTORY_LIMIT = int(os.getenv("HISTORY_LIMIT", "1000"))  # rows to keep per symbol in DB

TOKEN_FILE = "token.txt"
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", None)

# --- Logging setup ---
logger = logging.getLogger(APP_NAME)
logger.setLevel(logging.INFO)
fmt = logging.Formatter("%(asctime)s [%(levelname)s] %(message)s")

sh = logging.StreamHandler(sys.stdout)
sh.setFormatter(fmt)
logger.addHandler(sh)

fh = logging.FileHandler(LOG_FILE)
fh.setFormatter(fmt)
logger.addHandler(fh)

logger.info("Starting %s", APP_NAME)

# ---------------- Token loading ----------------
def load_token_file():
    if os.path.exists(TOKEN_FILE):
        try:
            with open(TOKEN_FILE, "r", encoding="utf-8") as f:
                t = f.read().strip()
                if t:
                    logger.info("Loaded token from %s", TOKEN_FILE)
                    return t
        except Exception:
            logger.exception("Failed to read token file")
    return None

def save_token_file(token):
    try:
        with open(TOKEN_FILE, "w", encoding="utf-8") as f:
            f.write(token)
        logger.info("Saved token to %s", TOKEN_FILE)
    except Exception:
        logger.exception("Failed to save token file")

if not TELEGRAM_TOKEN:
    TELEGRAM_TOKEN = load_token_file()

if not TELEGRAM_TOKEN:
    logger.critical("TELEGRAM_TOKEN not set in env and token.txt missing. Set TELEGRAM_TOKEN env var in Railway or create token.txt.")
    raise RuntimeError("TELEGRAM_TOKEN not set")

# if token present in env but not in file, save for convenience
if TELEGRAM_TOKEN and not os.path.exists(TOKEN_FILE):
    try:
        save_token_file(TELEGRAM_TOKEN)
    except Exception:
        pass

# ---------------- Exchange init ----------------
try:
    exchange = getattr(ccxt, DEFAULT_EXCHANGE_ID)({"enableRateLimit": True})
    logger.info("Initialized ccxt exchange: %s", DEFAULT_EXCHANGE_ID)
except Exception:
    logger.exception("Failed to init exchange")
    exchange = None

# ---------------- Bot & Dispatcher ----------------
bot = Bot(token=TELEGRAM_TOKEN)
dp = Dispatcher(bot)

# Expose app for gunicorn (aiogram polling is used, but app variable required by Procfile)
# We'll provide a minimal ASGI app object name for gunicorn to import; it's not used for webhook here.
app = None

# ---------------- DB helpers (aiosqlite) ----------------
DB_INIT_SQL = """
CREATE TABLE IF NOT EXISTS users (
    chat_id TEXT PRIMARY KEY,
    created_at TEXT
);
CREATE TABLE IF NOT EXISTS user_symbols (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    chat_id TEXT,
    symbol TEXT
);
CREATE TABLE IF NOT EXISTS alerts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    chat_id TEXT,
    symbol TEXT,
    target REAL,
    target_is_percent INTEGER DEFAULT 0,
    alert_type TEXT DEFAULT 'cross', -- above/below/cross
    recurring INTEGER DEFAULT 0,
    active_until TEXT DEFAULT NULL,
    created_at TEXT
);
CREATE TABLE IF NOT EXISTS history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    symbol TEXT,
    price REAL,
    ts TEXT
);
CREATE TABLE IF NOT EXISTS logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    level TEXT,
    message TEXT,
    ts TEXT
);
CREATE TABLE IF NOT EXISTS user_settings (
    chat_id TEXT PRIMARY KEY,
    signals_enabled INTEGER DEFAULT 0,
    signal_symbol TEXT DEFAULT NULL,
    signal_timeframe TEXT DEFAULT NULL
);
"""

async def init_db():
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.executescript(DB_INIT_SQL)
            await db.commit()
        logger.info("DB initialized at %s", DB_PATH)
    except Exception:
        logger.exception("DB init failed")

asyncio.get_event_loop().run_until_complete(init_db())

# helper wrapper
async def db_execute(query, params=(), fetch=False, fetchone=False):
    try:
        async with aiosqlite.connect(DB_PATH) as db:
            await db.execute("PRAGMA journal_mode=WAL;")
            cur = await db.execute(query, params)
            if fetch:
                rows = await cur.fetchall()
                await db.commit()
                return rows
            if fetchone:
                row = await cur.fetchone()
                await db.commit()
                return row
            await db.commit()
    except Exception:
        logger.exception("DB error executing: %s %s", query, params)
    return None

# ---------------- Logging to DB ----------------
async def log_db(level, message):
    try:
        ts = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
        await db_execute("INSERT INTO logs (level, message, ts) VALUES (?, ?, ?)", (level.upper(), message, ts))
        if level.lower() == "error":
            logger.error(message)
        elif level.lower() == "warning":
            logger.warning(message)
        else:
            logger.info(message)
    except Exception:
        logger.exception("log_db failed")

# ---------------- In-memory caches ----------------
last_prices = {}  # symbol -> price
history_cache = defaultdict(lambda: deque(maxlen=HISTORY_LIMIT))  # symbol -> deque of (ts, price)

# ---------------- Utility functions ----------------
def safe_float(x, default=0.0):
    try:
        return float(x)
    except Exception:
        return default

def now_ts():
    return datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")

# ---------------- Indicator implementations (fallbacks if ta not installed) ----------------
def sma(series, window):
    return series.rolling(window=window).mean()

def ema(series, window):
    return series.ewm(span=window, adjust=False).mean()

def rsi(series, period=14):
    # pandas Series input
    delta = series.diff()
    up = delta.clip(lower=0)
    down = -delta.clip(upper=0)
    ma_up = up.ewm(alpha=1/period, adjust=False).mean()
    ma_down = down.ewm(alpha=1/period, adjust=False).mean()
    rs = ma_up / ma_down
    rsi = 100 - 100 / (1 + rs)
    return rsi

def macd(series, fast=12, slow=26, signal=9):
    ema_fast = ema(series, fast)
    ema_slow = ema(series, slow)
    macd_line = ema_fast - ema_slow
    signal_line = macd_line.ewm(span=signal, adjust=False).mean()
    hist = macd_line - signal_line
    return macd_line, signal_line, hist

def bollinger_bands(series, window=20, devs=2):
    ma = series.rolling(window=window).mean()
    sd = series.rolling(window=window).std()
    upper = ma + devs * sd
    lower = ma - devs * sd
    return ma, upper, lower

def stochastic_oscillator(df, k_period=14, d_period=3):
    low_min = df['low'].rolling(window=k_period).min()
    high_max = df['high'].rolling(window=k_period).max()
    k = 100 * (df['close'] - low_min) / (high_max - low_min)
    d = k.rolling(window=d_period).mean()
    return k, d

# ADX (simplified)
def adx(df, period=14):
    high = df['high']; low = df['low']; close = df['close']
    plus_dm = high.diff()
    minus_dm = -low.diff()
    plus_dm[plus_dm < 0] = 0
    minus_dm[minus_dm < 0] = 0
    tr1 = high - low
    tr2 = (high - close.shift()).abs()
    tr3 = (low - close.shift()).abs()
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    atr = tr.ewm(alpha=1/period, adjust=False).mean()
    plus_di = 100 * (plus_dm.ewm(alpha=1/period, adjust=False).mean() / atr)
    minus_di = 100 * (minus_dm.ewm(alpha=1/period, adjust=False).mean() / atr)
    dx = (abs(plus_di - minus_di) / (plus_di + minus_di)) * 100
    adx = dx.ewm(alpha=1/period, adjust=False).mean()
    return adx

# ---------------- Chart generation ----------------
def generate_candlestick_chart(df, symbol, timeframe, add_indicators=None):
    """
    df: DataFrame with open, high, low, close, volume and datetime index
    returns bytesIO image
    """
    try:
        # use mplfinance
        img_buf = io = None
        import io as _io
        img_buf = _io.BytesIO()
        ap = []
        # draw moving averages if requested
        mav = None
        if add_indicators and "ma" in add_indicators:
            mav = add_indicators.get("ma")  # list of ints
        # convert index to datetime if not
        df_local = df.copy()
        if not isinstance(df_local.index, pd.DatetimeIndex):
            df_local.index = pd.to_datetime(df_local.index)
        mpf.plot(df_local, type='candle', style='yahoo', mav=mav, volume=True, show_nontrading=False, savefig=img_buf, figsize=(10,6))
        img_buf.seek(0)
        return img_buf
    except Exception:
        logger.exception("generate_candlestick_chart failed")
        return None

# ---------------- Price fetching ----------------
async def fetch_price(symbol):
    """Fetch latest ticker price for symbol from ccxt"""
    try:
        if not exchange:
            return None
        t = exchange.fetch_ticker(symbol)
        price = safe_float(t.get("last") or t.get("close") or 0.0)
        return price
    except Exception:
        logger.exception("fetch_price failed for %s", symbol)
        return None

async def fetch_ohlcv(symbol, timeframe='5m', limit=200):
    """Fetch OHLCV via ccxt for charts and indicators"""
    try:
        if not exchange:
            return None
        # some exchanges require symbol names like BTC/USDT
        data = exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit)
        # convert to DataFrame
        df = pd.DataFrame(data, columns=['ts','open','high','low','close','volume'])
        df['datetime'] = pd.to_datetime(df['ts'], unit='ms')
        df.set_index('datetime', inplace=True)
        return df[['open','high','low','close','volume']]
    except Exception:
        logger.exception("fetch_ohlcv failed for %s %s", symbol, timeframe)
        return None

# ---------------- Background price poller ----------------
async def price_polling_worker():
    logger.info("Price polling worker started, interval %s sec", PRICE_POLL_INTERVAL)
    while True:
        try:
            # gather distinct symbols from DB + defaults
            rows = await db_execute("SELECT DISTINCT symbol FROM user_symbols", fetch=True) or []
            symbols = set(["BTC/USDT", "ETH/USDT", "SOL/USDT", "NEAR/USDT"])
            symbols.update([r[0] for r in rows])
            # fetch each symbol
            for s in list(symbols):
                try:
                    p = await asyncio.get_event_loop().run_in_executor(None, lambda: exchange.fetch_ticker(s))
                    price = safe_float(p.get("last") or p.get("close") or 0.0)
                    last_prices[s] = price
                    ts = now_ts()
                    # save to DB history
                    await db_execute("INSERT INTO history (symbol, price, ts) VALUES (?, ?, ?)", (s, price, ts))
                    # update in-memory cache
                    history_cache[s].append((ts, price))
                except Exception:
                    logger.exception("inner fetch loop error for %s", s)
            # check alerts after updating
            await check_alerts()
        except Exception:
            logger.exception("price_polling_worker top-level error")
        await asyncio.sleep(PRICE_POLL_INTERVAL)

# ---------------- Alerts checking ----------------
async def get_all_alerts():
    rows = await db_execute("SELECT id, chat_id, symbol, target, target_is_percent, alert_type, recurring, active_until FROM alerts", fetch=True)
    return rows or []

async def check_alerts():
    try:
        alerts = await get_all_alerts()
        for a in alerts:
            aid, chat_id, symbol, target, target_is_percent, alert_type, recurring, active_until = a
            # check expiry
            if active_until:
                try:
                    dt = datetime.strptime(active_until, "%Y-%m-%d %H:%M:%S")
                    if datetime.utcnow() > dt:
                        await db_execute("DELETE FROM alerts WHERE id=?", (aid,))
                        continue
                except Exception:
                    pass
            # get price
            price = last_prices.get(symbol)
            if price is None:
                continue
            # interpret target
            trigger = False
            if target_is_percent:
                # target is percent change threshold relative to last recorded price stored in history_cache first element
                hist = history_cache.get(symbol)
                if hist and len(hist) >= 1:
                    baseline = hist[-1][1]  # last
                    threshold_price = baseline * (1 + target/100.0)
                else:
                    threshold_price = price
            else:
                threshold_price = target
            # determine depending on alert_type
            if alert_type == 'above':
                if price >= threshold_price:
                    trigger = True
            elif alert_type == 'below':
                if price <= threshold_price:
                    trigger = True
            elif alert_type == 'cross':
                # cross meaning price touched target this tick — use previous value vs current
                hist = history_cache.get(symbol)
                if hist and len(hist) >= 2:
                    prev = hist[-2][1]
                    cur = price
                    if (prev < threshold_price and cur >= threshold_price) or (prev > threshold_price and cur <= threshold_price):
                        trigger = True
            if trigger:
                try:
                    await bot.send_message(chat_id, f"🔔 Alert triggered for {symbol}\nType: {alert_type}\nTarget: {target}{'%' if target_is_percent else '$'}\nPrice: {price}$")
                    await log_db("info", f"Alert fired {aid} for {chat_id} {symbol} {target}")
                except Exception:
                    logger.exception("Failed sending alert message")
                if not recurring:
                    await db_execute("DELETE FROM alerts WHERE id=?", (aid,))
    except Exception:
        logger.exception("check_alerts failed")

# ---------------- Signal generation (autogenerated signals) ----------------
async def generate_signal_for_symbol(symbol, timeframe='5m'):
    """
    Very simple example signal combining indicators:
    - Trend by EMA crossover (fast EMA > slow EMA) bullish
    - RSI < 30 oversold (bullish) >70 overbought (bearish)
    - MACD histogram positive/negative
    Returns: dict with 'signal': 'long'/'short'/'none', 'score': float, 'explain': str
    """
    try:
        df = await fetch_ohlcv(symbol, timeframe=timeframe, limit=200)
        if df is None or len(df) < 30:
            return {"signal":"none", "score":0.0, "explain":"insufficient data"}
        close = df['close']
        ema_fast = ema(close, 12)
        ema_slow = ema(close, 26)
        macd_line, sig_line, hist = macd(close)
        rsi_v = rsi(close).iloc[-1]
        score = 0.0
        reasons = []
        # EMA trend
        if ema_fast.iloc[-1] > ema_slow.iloc[-1]:
            score += 1.0
            reasons.append("EMA fast > EMA slow")
        else:
            score -= 1.0
            reasons.append("EMA fast < EMA slow")
        # MACD
        if hist.iloc[-1] > 0:
            score += 0.8; reasons.append("MACD hist > 0")
        else:
            score -= 0.8; reasons.append("MACD hist < 0")
        # RSI
        if rsi_v < 30:
            score += 1.2; reasons.append(f"RSI {rsi_v:.1f} oversold")
        elif rsi_v > 70:
            score -= 1.2; reasons.append(f"RSI {rsi_v:.1f} overbought")
        else:
            reasons.append(f"RSI {rsi_v:.1f} neutral")
        # Bollinger squeeze detection (narrow bands)
        ma, upper, lower = bollinger_bands(close, window=20, devs=2)
        width = (upper - lower).iloc[-1] / ma.iloc[-1] if ma.iloc[-1] != 0 else 0
        if width < 0.02:
            reasons.append("Bollinger narrow (low volatility)")
            score += 0.3
        # simple final decision
        if score >= 1.0:
            return {"signal":"long", "score":score, "explain":"; ".join(reasons)}
        if score <= -1.0:
            return {"signal":"short", "score":score, "explain":"; ".join(reasons)}
        return {"signal":"none", "score":score, "explain":"; ".join(reasons)}
    except Exception:
        logger.exception("generate_signal_for_symbol failed for %s %s", symbol, timeframe)
        return {"signal":"none", "score":0.0, "explain":"error"}

async def signal_worker():
    logger.info("Signal worker started, interval %s sec", SIGNAL_CHECK_INTERVAL)
    while True:
        try:
            # iterate users who have signals_enabled
            rows = await db_execute("SELECT chat_id, signal_symbol, signal_timeframe FROM user_settings WHERE signals_enabled=1", fetch=True) or []
            for chat_id, symbol, timeframe in rows:
                if not symbol:
                    continue
                timeframe = timeframe or "5m"
                result = await generate_signal_for_symbol(symbol, timeframe=timeframe)
                if result and result.get("signal") in ("long","short"):
                    try:
                        text = f"📣 Авто-сигнал {result['signal'].upper()} для {symbol} ({timeframe})\nОценка: {result['score']:.2f}\nПричины: {result['explain']}"
                        await bot.send_message(chat_id, text)
                        await log_db("info", f"Auto-signal sent to {chat_id} {symbol} {timeframe} -> {result['signal']}")
                    except Exception:
                        logger.exception("Failed to send auto-signal to %s", chat_id)
        except Exception:
            logger.exception("signal_worker iteration error")
        await asyncio.sleep(SIGNAL_CHECK_INTERVAL)

# ---------------- Keyboards ----------------
def main_menu_kb():
    kb = InlineKeyboardMarkup(row_width=2)
    kb.add(
        InlineKeyboardButton("💰 Все цены", callback_data="all_prices"),
        InlineKeyboardButton("📊 График", callback_data="chart_menu")
    )
    kb.add(
        InlineKeyboardButton("🔔 Добавить Alert", callback_data="add_alert"),
        InlineKeyboardButton("📋 Мои Alerts", callback_data="my_alerts")
    )
    kb.add(
        InlineKeyboardButton("⚙️ Мои монеты", callback_data="my_symbols"),
        InlineKeyboardButton("🤖 Авто-сигналы", callback_data="signals_menu")
    )
    return kb

def symbol_selection_kb(symbols):
    # build rows of 3
    kb = InlineKeyboardMarkup(row_width=3)
    for s in symbols:
        kb.insert(InlineKeyboardButton(s.split("/")[0], callback_data=f"select_sym|{s}"))
    kb.add(InlineKeyboardButton("⬅️ Назад", callback_data="back_main"))
    return kb

def timeframe_kb():
    kb = InlineKeyboardMarkup(row_width=3)
    kb.add(
        InlineKeyboardButton("1m", callback_data="tf|1m"),
        InlineKeyboardButton("5m", callback_data="tf|5m"),
        InlineKeyboardButton("15m", callback_data="tf|15m"),
        InlineKeyboardButton("30m", callback_data="tf|30m"),
        InlineKeyboardButton("1h", callback_data="tf|1h"),
        InlineKeyboardButton("4h", callback_data="tf|4h"),
        InlineKeyboardButton("1d", callback_data="tf|1d"),
    )
    kb.add(InlineKeyboardButton("⬅️ Назад", callback_data="back_main"))
    return kb

# ---------------- Command & Callback Handlers ----------------
@dp.message_handler(commands=["start"])
async def cmd_start(message: types.Message):
    try:
        # add user
        await db_execute("INSERT OR IGNORE INTO users (chat_id, created_at) VALUES (?, ?)", (str(message.chat.id), now_ts()))
        await message.reply("👋 Привет! Я крипто-бот. Меню ниже.", reply_markup=main_menu_kb())
    except Exception:
        logger.exception("cmd_start failed")
        await message.reply("Ошибка при старте. Попробуйте позже.")

@dp.callback_query_handler(lambda c: c.data == "back_main")
async def on_back_main(cb: types.CallbackQuery):
    try:
        await cb.answer()
        await bot.send_message(cb.from_user.id, "Главное меню:", reply_markup=main_menu_kb())
    except Exception:
        logger.exception("on_back_main failed")

@dp.callback_query_handler(lambda c: c.data == "all_prices")
async def on_all_prices(cb: types.CallbackQuery):
    try:
        await cb.answer()
        # gather symbols in DB + defaults
        rows = await db_execute("SELECT DISTINCT symbol FROM user_symbols", fetch=True) or []
        symbols = set(["BTC/USDT","ETH/USDT","SOL/USDT","NEAR/USDT"])
        symbols.update([r[0] for r in rows])
        lines = []
        for s in sorted(symbols):
            p = last_prices.get(s)
            lines.append(f"{s}: {p if p is not None else 'n/a'}$")
        text = "💱 Текущие цены:\n" + "\n".join(lines)
        await bot.send_message(cb.from_user.id, text, reply_markup=main_menu_kb())
    except Exception:
        logger.exception("on_all_prices failed")
        await cb.answer("Ошибка получения цен", show_alert=True)

@dp.callback_query_handler(lambda c: c.data == "chart_menu")
async def on_chart_menu(cb: types.CallbackQuery):
    try:
        await cb.answer()
        # show symbol selection
        rows = await db_execute("SELECT DISTINCT symbol FROM user_symbols", fetch=True) or []
        symbols = ["BTC/USDT","ETH/USDT","SOL/USDT","NEAR/USDT"]
        symbols += [r[0] for r in rows]
        kb = symbol_selection_kb(symbols)
        await bot.send_message(cb.from_user.id, "Выберите монету для графика:", reply_markup=kb)
    except Exception:
        logger.exception("on_chart_menu failed")
        await cb.answer("Ошибка", show_alert=True)

@dp.callback_query_handler(lambda c: c.data and c.data.startswith("select_sym|"))
async def on_select_sym(cb: types.CallbackQuery):
    try:
        await cb.answer()
        payload = cb.data.split("|",1)[1]
        # store in in-memory pending selection using message id and user id
        await bot.send_message(cb.from_user.id, f"Монета {payload} выбрана. Выберите таймфрейм:", reply_markup=timeframe_kb())
        # save pending in user_settings as temporary selection
        await db_execute("INSERT OR REPLACE INTO user_settings (chat_id, signals_enabled, signal_symbol, signal_timeframe) VALUES (?, COALESCE((SELECT signals_enabled FROM user_settings WHERE chat_id=?),0), ?, ?)", (str(cb.from_user.id), str(cb.from_user.id), payload, None))
    except Exception:
        logger.exception("on_select_sym failed")

@dp.callback_query_handler(lambda c: c.data and c.data.startswith("tf|"))
async def on_select_tf(cb: types.CallbackQuery):
    try:
        await cb.answer()
        tf = cb.data.split("|",1)[1]
        # find pending symbol from user_settings
        row = await db_execute("SELECT signal_symbol FROM user_settings WHERE chat_id=?", (str(cb.from_user.id),), fetchone=True)
        symbol = row[0] if row else None
        # if none, ask to select symbol first
        if not symbol:
            await bot.send_message(cb.from_user.id, "Сначала выберите монету.", reply_markup=main_menu_kb())
            return
        # fetch chart and send
        await bot.send_message(cb.from_user.id, f"Генерирую график {symbol} {tf} ...")
        df = await fetch_ohlcv(symbol, timeframe=tf, limit=200)
        if df is None:
            await bot.send_message(cb.from_user.id, "Ошибка получения данных для графика.")
            return
        # build candlestick chart bytes
        try:
            # convert index if needed
            buf = None
            try:
                buf = generate_candlestick_chart(df, symbol, tf, add_indicators={"ma":[5,20]})
            except Exception:
                buf = None
            if not buf:
                # fallback: simple matplotlib
                import io
                fig, ax = plt.subplots(figsize=(10,4))
                ax.plot(df.index, df['close'])
                ax.set_title(f"{symbol} {tf}")
                ax.grid(True)
                img = io.BytesIO()
                fig.tight_layout()
                fig.savefig(img, format="png", dpi=150)
                plt.close(fig)
                img.seek(0)
                buf = img
            await bot.send_photo(cb.from_user.id, buf, caption=f"{symbol} {tf} — график")
        except Exception:
            logger.exception("chart send failed")
            await bot.send_message(cb.from_user.id, "Ошибка при генерации графика.")
    except Exception:
        logger.exception("on_select_tf failed")

# ---------------- Add Alert Flow ----------------
# We'll use simple states stored in memory for pending flows (per-user). For production use FSM better.
PENDING = {}

@dp.callback_query_handler(lambda c: c.data == "add_alert")
async def on_add_alert(cb: types.CallbackQuery):
    try:
        await cb.answer()
        # ask to choose symbol via keyboard
        rows = await db_execute("SELECT DISTINCT symbol FROM user_symbols", fetch=True) or []
        symbols = ["BTC/USDT","ETH/USDT","SOL/USDT","NEAR/USDT"]
        symbols += [r[0] for r in rows]
        kb = symbol_selection_kb(symbols)
        await bot.send_message(cb.from_user.id, "Выберите монету для Alert:", reply_markup=kb)
        # set state in PENDING mapping that we are adding alert
        PENDING[str(cb.from_user.id)] = {"flow":"add_alert_select_symbol"}
    except Exception:
        logger.exception("on_add_alert failed")

@dp.callback_query_handler(lambda c: c.data and c.data.startswith("select_sym|"))
async def on_add_alert_select_sym(cb: types.CallbackQuery):
    try:
        await cb.answer()
        user = str(cb.from_user.id)
        payload = cb.data.split("|",1)[1]
        state = PENDING.get(user, {})
        # if flow is add_alert_select_symbol, continue
        if state.get("flow") == "add_alert_select_symbol":
            # save symbol and ask whether $ or %
            PENDING[user] = {"flow":"add_alert_enter_type", "symbol":payload}
            kb = InlineKeyboardMarkup(row_width=2)
            kb.add(InlineKeyboardButton("$ (amount)", callback_data="alert_type$"), InlineKeyboardButton("% (percent)", callback_data="alert_type%"))
            kb.add(InlineKeyboardButton("⬅️ Отмена", callback_data="back_main"))
            await bot.send_message(cb.from_user.id, f"Выбрана {payload}. Выберите тип таргета:", reply_markup=kb)
        else:
            # other flows may use select_sym; ignore
            pass
    except Exception:
        logger.exception("on_add_alert_select_sym failed")

@dp.callback_query_handler(lambda c: c.data in ("alert_type$","alert_type%"))
async def on_alert_type_choice(cb: types.CallbackQuery):
    try:
        await cb.answer()
        user = str(cb.from_user.id)
        state = PENDING.get(user)
        if not state or state.get("flow") != "add_alert_enter_type":
            await bot.send_message(cb.from_user.id, "Нечего сохранять. Начните создание alert заново.", reply_markup=main_menu_kb())
            return
        typ = cb.data
        PENDING[user]["target_is_percent"] = 1 if typ == "alert_type%" else 0
        PENDING[user]["flow"] = "add_alert_enter_value"
        await bot.send_message(cb.from_user.id, "Введите число — значение таргета (например: 30000 или 5 для 5%):")
    except Exception:
        logger.exception("on_alert_type_choice failed")

@dp.message_handler()
async def generic_message_handler(message: types.Message):
    try:
        user = str(message.chat.id)
        state = PENDING.get(user)
        text = (message.text or "").strip()
        if state and state.get("flow") == "add_alert_enter_value":
            # parse numeric
            try:
                value = float(text.replace(",","."))
            except Exception:
                await message.reply("Неверный формат числа. Введите число (например: 30000 или 5).")
                return
            symbol = state.get("symbol")
            is_percent = state.get("target_is_percent", 0)
            # default type: cross
            await db_execute("INSERT INTO alerts (chat_id, symbol, target, target_is_percent, alert_type, recurring, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)",
                             (user, symbol, value, is_percent, "cross", 0, now_ts()))
            await message.reply(f"✅ Alert добавлен: {symbol} target {value}{'%' if is_percent else '$'}", reply_markup=main_menu_kb())
            await log_db("info", f"Alert added for {user} {symbol} {value} {'%' if is_percent else '$'}")
            # clear pending
            PENDING.pop(user, None)
            return
        # Other flows may need handling (e.g., add_symbol custom input)
        # If message not part of flows - show main menu
        await message.reply("Команда не распознана. Меню:", reply_markup=main_menu_kb())
    except Exception:
        logger.exception("generic_message_handler failed")

@dp.callback_query_handler(lambda c: c.data == "my_alerts")
async def on_my_alerts(cb: types.CallbackQuery):
    try:
        await cb.answer()
        rows = await db_execute("SELECT id, symbol, target, target_is_percent, alert_type, recurring, created_at FROM alerts WHERE chat_id=? ORDER BY id DESC", (str(cb.from_user.id),), fetch=True) or []
        if not rows:
            await bot.send_message(cb.from_user.id, "У вас нет Alerts.", reply_markup=main_menu_kb())
            return
        kb = InlineKeyboardMarkup()
        for r in rows:
            aid, sym, targ, tpercent, atype, rec, created = r
            label = f"{sym} {atype} {targ}{'%' if tpercent else '$'}"
            kb.add(InlineKeyboardButton(label, callback_data=f"del_alert|{aid}"))
        kb.add(InlineKeyboardButton("⬅️ Назад", callback_data="back_main"))
        await bot.send_message(cb.from_user.id, "Ваши Alerts (нажмите чтобы удалить):", reply_markup=kb)
    except Exception:
        logger.exception("on_my_alerts failed")

@dp.callback_query_handler(lambda c: c.data and c.data.startswith("del_alert|"))
async def on_del_alert(cb: types.CallbackQuery):
    try:
        await cb.answer()
        aid = int(cb.data.split("|",1)[1])
        await db_execute("DELETE FROM alerts WHERE id=? AND chat_id=?", (aid, str(cb.from_user.id)))
        await bot.send_message(cb.from_user.id, "✅ Alert удалён.", reply_markup=main_menu_kb())
    except Exception:
        logger.exception("on_del_alert failed")
        await cb.answer("Ошибка удаления", show_alert=True)

# ---------------- My symbols management ----------------
@dp.callback_query_handler(lambda c: c.data == "my_symbols")
async def on_my_symbols(cb: types.CallbackQuery):
    try:
        await cb.answer()
        rows = await db_execute("SELECT symbol FROM user_symbols WHERE chat_id=?", (str(cb.from_user.id),), fetch=True) or []
        syms = [r[0] for r in rows]
        if not syms:
            syms = ["BTC/USDT","ETH/USDT","SOL/USDT","NEAR/USDT"]
        kb = InlineKeyboardMarkup()
        for s in syms:
            kb.add(InlineKeyboardButton(s, callback_data=f"remove_sym|{s}"))
        kb.add(InlineKeyboardButton("➕ Добавить монету", callback_data="add_symbol"))
        kb.add(InlineKeyboardButton("⬅️ Назад", callback_data="back_main"))
        await bot.send_message(cb.from_user.id, "Ваши монеты (нажмите чтобы удалить):", reply_markup=kb)
    except Exception:
        logger.exception("on_my_symbols failed")

@dp.callback_query_handler(lambda c: c.data == "add_symbol")
async def on_add_symbol(cb: types.CallbackQuery):
    try:
        await cb.answer()
        PENDING[str(cb.from_user.id)] = {"flow":"add_symbol"}
        await bot.send_message(cb.from_user.id, "Отправьте символ монеты (например ADA или ADA/USDT):")
    except Exception:
        logger.exception("on_add_symbol failed")

@dp.callback_query_handler(lambda c: c.data and c.data.startswith("remove_sym|"))
async def on_remove_sym(cb: types.CallbackQuery):
    try:
        await cb.answer()
        sym = cb.data.split("|",1)[1]
        await db_execute("DELETE FROM user_symbols WHERE chat_id=? AND symbol=?", (str(cb.from_user.id), sym))
        await bot.send_message(cb.from_user.id, f"Удалено: {sym}", reply_markup=main_menu_kb())
    except Exception:
        logger.exception("on_remove_sym failed")

# handle add_symbol input
@dp.message_handler()
async def add_symbol_text(message: types.Message):
    try:
        user = str(message.chat.id)
        state = PENDING.get(user)
        if state and state.get("flow") == "add_symbol":
            sym = message.text.strip().upper()
            if "/" not in sym:
                sym = sym + "/USDT"
            # validate on exchange
            try:
                markets = exchange.load_markets()
                if sym in markets:
                    await db_execute("INSERT INTO user_symbols (chat_id, symbol) VALUES (?, ?)", (user, sym))
                    await message.reply(f"✅ Монета {sym} добавлена.", reply_markup=main_menu_kb())
                else:
                    await message.reply(f"❌ Пара {sym} не найдена на бирже.", reply_markup=main_menu_kb())
            except Exception:
                logger.exception("market check failed")
                await message.reply("Ошибка проверки пары на бирже.", reply_markup=main_menu_kb())
            PENDING.pop(user, None)
            return
        # if not handling add_symbol, generic handler in above generic_message_handler will reply
    except Exception:
        logger.exception("add_symbol_text failed")

# ---------------- Signals menu & toggle ----------------
@dp.callback_query_handler(lambda c: c.data == "signals_menu")
async def on_signals_menu(cb: types.CallbackQuery):
    try:
        await cb.answer()
        # read user setting
        row = await db_execute("SELECT signals_enabled, signal_symbol, signal_timeframe FROM user_settings WHERE chat_id=?", (str(cb.from_user.id),), fetchone=True)
        enabled = row[0] if row else 0
        symbol = row[1] if row else None
        timeframe = row[2] if row else None
        kb = InlineKeyboardMarkup(row_width=1)
        kb.add(InlineKeyboardButton("🔁 Вкл/Выкл авто-сигналы", callback_data="toggle_signals"))
        kb.add(InlineKeyboardButton("⏱ Выбрать монету (для автосигналов)", callback_data="chart_menu"))
        kb.add(InlineKeyboardButton("⬅️ Назад", callback_data="back_main"))
        await bot.send_message(cb.from_user.id, f"Авто-сигналы: {'Вкл' if enabled else 'Выкл'}\nМонета: {symbol or '-'}\nTF: {timeframe or '-'}", reply_markup=kb)
    except Exception:
        logger.exception("on_signals_menu failed")

@dp.callback_query_handler(lambda c: c.data == "toggle_signals")
async def toggle_signals(cb: types.CallbackQuery):
    try:
        await cb.answer()
        row = await db_execute("SELECT signals_enabled FROM user_settings WHERE chat_id=?", (str(cb.from_user.id),), fetchone=True)
        cur = row[0] if row else 0
        new = 0 if cur == 1 else 1
        await db_execute("INSERT OR REPLACE INTO user_settings (chat_id, signals_enabled, signal_symbol, signal_timeframe) VALUES (?, ?, COALESCE((SELECT signal_symbol FROM user_settings WHERE chat_id=?), NULL), COALESCE((SELECT signal_timeframe FROM user_settings WHERE chat_id=?), NULL))",
                         (str(cb.from_user.id), new, str(cb.from_user.id), str(cb.from_user.id)))
        await bot.send_message(cb.from_user.id, f"Авто-сигналы {'включены' if new==1 else 'выключены'}.", reply_markup=main_menu_kb())
    except Exception:
        logger.exception("toggle_signals failed")

# ---------------- Startup & background tasks ----------------
async def on_startup(dispatcher):
    try:
        logger.info("Bot starting. Scheduling background workers...")
        # schedule price poller and signals via tasks
        asyncio.create_task(price_polling_worker())
        asyncio.create_task(signal_worker())
    except Exception:
        logger.exception("on_startup failed")

async def on_shutdown(dispatcher):
    try:
        logger.info("Shutting down: stopping background tasks")
        await bot.close()
    except Exception:
        logger.exception("on_shutdown failed")

# ---------------- Utility: get default symbols list ----------------
async def get_symbols_for_user(chat_id):
    rows = await db_execute("SELECT symbol FROM user_symbols WHERE chat_id=?", (str(chat_id),), fetch=True) or []
    if rows:
        return [r[0] for r in rows]
    return ["BTC/USDT","ETH/USDT","SOL/USDT","NEAR/USDT"]

# ---------------- Run ----------------
if __name__ == "__main__":
    # Run long-running loop
    try:
        logger.info("Start polling.")
        executor.start_polling(dp, skip_updates=True, on_startup=on_startup, on_shutdown=on_shutdown)
    except Exception:
        logger.exception("Bot crashed on start")
